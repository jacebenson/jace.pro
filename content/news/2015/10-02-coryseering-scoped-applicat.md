---
title: "Scoped Applications and Client Scripts A Primer"
date: 2015-10-02T03:28:37.000Z
link: "https://community.servicenow.com/community?id=community_blog&sys_id=788c66e1dbd0dbc01dcaf3231f961969"
---
<p>I spent some time this morning looking for a link or a document about the unique environment <a title="ki.servicenow.com/index.php?title=Client_Scripts" href="ttps://wiki.servicenow.com/index.php?title=Client_Scripts">Client Scripts</a> which are part of a <a title="iki.servicenow.com/index.php?title=Applications" href="https://wiki.servicenow.com/index.php?title=Applications">Scoped Application</a> execute in. I wasn't able to find an official document outlining the details, not in the <a title="iki.servicenow.com/" href="https://wiki.servicenow.com/">Wiki</a>, nor in the <a title="eveloper.servicenow.com/app.do#!/api_doc" href="https://developer.servicenow.com/app.do#!/api_doc">Developer API Reference</a>, nor in the KB on <a title="i.service-now.com/" href="https://hi.service-now.com/">Hi</a>. Since I implemented most of this functionality, I thought I'd write up a blog post explaining it. We'll also work on official documentation in the correct places, of course.</p><p></p><h2>What are the differences between a scoped Client Script and a global one?</h2><p></p><p>Scoped Client Scripts- Client Scripts which are created as part of a Scoped Application- are executed slightly differently than their non-scoped counterparts. They are wrapped in a closure, and certain APIs that would normally be accessible are either modified, or unavailable altogether. We'll get into the reasons later on, but here is a quick rundown of the differences.</p><p></p><table border="1" class="jiveBorder" jive-data-cell="{&quot;color&quot;:&quot;#575757&quot;,&quot;textAlign&quot;:&quot;left&quot;,&quot;padding&quot;:&quot;2&quot;,&quot;backgroundColor&quot;:&quot;transparent&quot;,&quot;fontFamily&quot;:&quot;arial,helvetica,sans-serif&quot;,&quot;verticalAlign&quot;:&quot;baseline&quot;}" jive-data-header="{&quot;color&quot;:&quot;#FFFFFF&quot;,&quot;backgroundColor&quot;:&quot;#6690BC&quot;,&quot;textAlign&quot;:&quot;center&quot;,&quot;padding&quot;:&quot;2&quot;}" style="border: 1px solid #000000; width: 100%;"><tbody><tr><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle"><h3>Inaccessible APIs</h3></th><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle"><h3>Modified APIs</h3></th></tr><tr><td style="padding: 2px;"><ul style="list-style-type: circle;"><li>GlideRecord</li><li>window</li><li>document</li><li>$ (Prototype library)</li><li>$$ (Prototype library selector shortcut)</li><li>jQuery</li><li>$j (jQuery shortcut)</li><li>$F (Sizzle form element value shortcut)</li></ul></td><td style="padding: 2px;"><ul style="list-style-type: circle;"><li>GlideAjax</li><li>g_form</li><li>GlideDialogWindow</li></ul></td></tr></tbody></table><p></p><p></p><p>Most of the inaccessible APIs can be re-enabled on a per-application basis. To do so, you need to ship a True/False <a title="iki.servicenow.com/index.php?title=Adding_a_Property" href="https://wiki.servicenow.com/index.php?title=Adding_a_Property">system property</a> in your application named <strong>glide.script.block.client.globals</strong> with the value <em>false</em>. As with all system properties in a Scoped Application, the name of the property will automatically have your application's <a title="iki.servicenow.com/index.php?title=Application_Scope" href="https://wiki.servicenow.com/index.php?title=Application_Scope">scope name</a> prefixed to it- you don't need to do that yourself. I see access to these global objects as a failure on our part to provide appropriate APIs. Direct <a title="eveloper.mozilla.org/en-US/docs/Web/API/Document_Object_Model" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM</a> manipulation is sometimes the only way to achieve a certain goal, but it's also prone to breaking between releases. Something that worked fine in <a title="iki.servicenow.com/index.php?title=Administering_the_User_Interface" href="https://wiki.servicenow.com/index.php?title=Administering_the_User_Interface">UI11</a> may not work in UI15, for example. By tracking which scoped applications needs these globals, we can better target our development efforts on creating or updating APIs to address those needs without resorting to the DOM.</p><p></p><p>I said most of the inaccessible APIs can be turned back on. There is only one that is not available even with that system property set to <em>false</em>- client-side <a href="https://wiki.servicenow.com/index.php?title=Client_Side_GlideRecord"><strong>GlideRecord</strong></a>. This should be considered deprecated. I would like to have removed it completely, but there is a lot of legacy code out there in the wild using it. Client-side GlideRecord has some convenience, but it comes at the cost of large payloads, and the fact that almost everybody using it does so synchronously. Everything client-side GlideRecord does can be done with <a title="iki.servicenow.com/index.php?title=GlideAjax" href="https://wiki.servicenow.com/index.php?title=GlideAjax">GlideAjax</a> and an appropriately-written <a title="iki.servicenow.com/index.php?title=Script_Includes" href="https://wiki.servicenow.com/index.php?title=Script_Includes">Script Include</a> or <a title="" _jive_internal="true" href="/community?id=community_blog&sys_id=adbd6aa9dbd0dbc01dcaf3231f9619e8">processor</a>.</p><p></p><h2>So what about the modified APIs?</h2><p></p><p>The version of GlideAjax that is available to scoped Client Scripts can only make <a title="iki.servicenow.com/index.php?title=GlideAjax#Asynchronous_Glide_Ajax" href="https://wiki.servicenow.com/index.php?title=GlideAjax#Asynchronous_Glide_Ajax">asynchronous</a> requests. Requests made from scoped GlideAjax requests will also take place within the application's scope. You don't need to prefix your scope name on calls to your Script Includes, and other scoped Client Scripts have to respect your access policies.</p><p></p><table border="1" class="jiveBorder" style="border: 1px solid #000000; width: 100%;"><tbody><tr><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle">Method</th><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle">Restriction</th><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle">Alternative</th></tr><tr><td style="padding: 2px;">getXMLWait</td><td style="padding: 2px;"><p>Not Supported</p></td><td style="padding: 2px;"><p>getXML(callback)</p><p>getXMLAnswer(callback)</p></td></tr></tbody></table><p></p><p>The scoped version of <a title="iki.servicenow.com/index.php?title=GlideForm_(g_form)" href="https://wiki.servicenow.com/index.php?title=GlideForm_(g_form)">g_form</a> is slightly more involved. Any calls to getReference must provide a <a title="vascriptissexy.com/understand-javascript-callback-functions-and-use-them/" href="http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/">callback function</a>. This makes it an asynchronous action, and doesn't hang the interface while the client is communicating with the server. Scoped applications cannot change the Mandatory, ReadOnly,   Display, or Disabled status of fields outside of their scope- with one interesting exception. If your Client Script runs on a table in your own application, and that table <a href="https://wiki.servicenow.com/index.php?title=Tables_and_Classes"><em>extends</em> a table from another scope</a>, the fields you <em>inherit</em> from that base table are considered in-scope when they are displayed on your form.</p><p></p><h3 style="padding-left: 30px;">What?</h3><p style="padding-left: 30px;">Consider the difference between <em>adding a field to the Incident table</em> and <em>extending Incident with a new table that has only one field</em>. In the first case, your field is being displayed on Incident. Client Scripts you add to the Incident table can do all the regular things with <em>your field</em> but are limited in what they can do to other fields. You cannot make the Caller mandatory and disable the Category field, because that could negatively affect the functionality of other Client Scripts and UI Policies on the Incident table.</p><p style="padding-left: 30px;">In the second case, where you extend Incident, you are <em>inheriting</em> the fields that are Incident (and in its parent chain), but nothing you do on this table can actually break the functionality of Incident itself. You can set fields to be Mandatory or Disabled or ReadOnly as your requirements dictate, without worrying that you might be breaking some other application. Similarly, fields added onto your table by other scopes (if your <a title="iki.servicenow.com/index.php?title=Application_Access_Settings#Set_Design-Time_Access_to_Application_Tables" href="https://wiki.servicenow.com/index.php?title=Application_Access_Settings#Set_Design-Time_Access_to_Application_Tables">Design-time Table Access</a> is set up to allow that) cannot break your application's functionality. If they add Client Scripts to your application, they can't break your carefully-crafted rules about which fields must be filled in by the user before submission, and they can't hold up your user's interaction because they want to make a lot of Ajax calls as part of their functionality.</p><p style="padding-left: 30px;"></p><table border="1" class="jiveBorder" style="border: 1px solid #000000; width: 100%;"><tbody><tr><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle">Method</th><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle">Restriction</th><th style="text-align: center; background-color: #6690bc; color: #ffffff; padding: 2px;" valign="middle">Alternative</th></tr><tr><td style="padding: 2px;">setReadOnly/setReadonly</td><td style="padding: 2px;">Can only apply to fields in the same scope as the calling script.</td><td style="padding: 2px;">Extend the table instead of adding a field to it</td></tr><tr><td style="padding: 2px;">setMandatory</td><td style="padding: 2px;">Can only apply to fields in the same scope as the calling script.</td><td style="padding: 2px;"><p>Extend the table instead of adding a field to it</p></td></tr><tr><td style="padding: 2px;">setDisabled</td><td style="padding: 2px;">Can only apply to fields in the same scope as the calling script.</td><td style="padding: 2px;">Extend the table instead of adding a field to it</td></tr><tr><td style="padding: 2px;">setDisplay</td><td style="padding: 2px;">Can only apply to fields in the same scope as the calling script.</td><td style="padding: 2px;">Extend the table instead of adding a field to it</td></tr><tr><td style="padding: 2px;">getReference</td><td style="padding: 2px;">Must use a callback</td><td style="padding: 2px;">g_form.getReference("ref_field",callback);</td></tr></tbody></table><p></p><p>The scoped version of <a title="iki.servicenow.com/index.php?title=Displaying_a_Custom_Dialog" href="https://wiki.servicenow.com/index.php?title=Displaying_a_Custom_Dialog">GlideDialogWindow</a> is only marginally interesting. When making calls to GlideDialogWindow, HTML is generated server-side, and then passed down to the client to be displayed. The change to this API is invisible to your application- it merely ensures that the HTML that gets generated is appropriate for your scope. For instance, if you are rendering a form that contains Client Scripts, those Client Scripts are appropriately scoped as well.</p><p></p><h2>You mentioned a closure?</h2><p></p><p>Technically it's an <a title="n.wikipedia.org/wiki/Immediately-invoked_function_expression" href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IIFE</a>- an immediately-invoked function expression. We wrap your scoped Client Scripts in a <a title="eveloper.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">strict-mode</a> IIFE to provide the appropriate environment, and to prevent leaking variables into the global scope. This prevents two Client Scripts from accidentally overwriting one another's variables and functions. This doesn't remove access to everything in the <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch2.md#chapter-2-lexical-scope"><em>global lexical scope</em></a>, it just makes sure that variables and functions you declare don't change underneath you because someone else also likes those names. The downside to this approach is with <em>sharing functions between Client Scripts</em>. In the old model, you could close your onChange or onLoad script, define a function, and it would be available to your other Client Scripts because it was part of the global window object. With the new approach, shared functions need to be defined in UI Scripts. The new model for Scoped <a title="iki.servicenow.com/index.php?title=UI_Scripts" href="https://wiki.servicenow.com/index.php?title=UI_Scripts">UI Scripts</a> creates an object in the global window with the same name as your scope, and allows you to add properties to this object which are then available to all your other UI Scripts and Client Scripts, just by accessing the object.</p><p></p><h3 style="padding-left: 30px;">What?</h3><p style="padding-left: 30px;">Ok, I realize I'm suddenly talking about UI Scripts, and we seem to have taken a left turn. Trust me, you want to know this.</p><p style="padding-left: 30px;">Scoped UI Scripts have a specific format that we'd <em>prefer</em> applications to adhere to. It's not a <em>requirement</em> because we recognize that UI Scripts serve many purposes, and that "acting as a library of shared functions" is only one of them. But if you adhere to the format that is pre-filled for you when you create your UI Script, you'll be able to add public methods to an object that <em>you control</em>, and can access those methods just by calling <em>scope_name.methodName()</em> in your Client Scripts (assuming the UI Script has been included on the form your script runs on). You can even define new properties on this object from within your Client Scripts, and therefore make them available to your other Client Scripts similar to how you did in the past- without worrying that you are clobbering some other global variable or function, and without worrying someone else is clobbering yours.</p><p style="padding-left: 30px;"></p><h3 style="padding-left: 30px;">That should probably be covered in some Best Practices documents, right?</h3><p style="padding-left: 30px;">I agree (not surprising- I wrote that question). In addition to the documentation on Client Scripts, we'll work on some examples that show how we envision all of this being put into practice.</p><p style="padding-left: 30px;"></p><h2>OK, but why (the short version)?</h2><p></p><p>There were 3 things we wanted to address:</p><ol><li>Reduce the likelihood that a misbehaving Client Script or a random client-side JavaScript error could break the interface for users.</li><li>Keep the interface responsive at all times.</li><li>Reduce the likelihood for conflicts between two Scoped Applications running at the same time.</li></ol><p></p><p>Every change that we made was done to address one of those 3 concerns. Asynchronous Ajax calls ensure that the interface remains snappy. IIFE's   make sure that someone's Floops app can't break your Spork form because they happen to also like the variable name "spoon", or they forgot a semicolon in a crucial place and JavaScript execution was halted. We also wanted to make sure that you don't have to constantly be referring to your own scope name. Client Scripts in your scope should not need to tell GlideAjax that they want to access the "alligatorDefenseProtocol" method on <em>your</em> Script Include named "HippopotamusFactoryGenerator" and not some other application's "HippopotamusFactoryGenerator" (which doesn't even include the "alligatorDefenseProtocol" method- how naive). GlideAjax should just know.</p><p></p><p>By pushing developers away from direct DOM manipulation and into supported APIs, we are trying to ensure that the application you build for <a title="iki.servicenow.com/index.php?title=Fuji_Release_Notes" href="https://wiki.servicenow.com/index.php?title=Fuji_Release_Notes">Fuji</a> keeps working on Geneva. If you build an application in UI14, it should work when the user switches to UI15. And when a new interface comes along, the app shouldn't need to worry about it- if it's using the supported APIs.</p><p></p><p>Most importantly (to me, anyway) is that users aren't negatively affected by applications. Something that they used yesterday still works today- even if an enhancement was added to the Incident form by way of a sweet new application that makes the entire form turn <span style="color: #7fff00;">chartreuse</span> when the Incident caller is a VIP, or which automatically searches previous incidents by the same Company for relevant issues so they can get up-to-speed quicker and deliver an answer that is more on-point than ever before. Enhancements and applications should make the experience better, they shouldn't be able to make it worse.</p><p></p><h2>That's a lot of information- what's the short, short version?</h2><p></p><p>Yes, it is. And that's not everything that I could say on this topic- I could probably talk for a couple of hours about it. But that's annoying because I tend to wander and get stuck in esoteric side-channels and bore the heck out of anyone unlucky enough to be within hearing range. So here is the short, short version:</p><p></p><ul><li><span style="font-size: 18pt;">ASYNC ALL THE THINGS</span></li><li><span style="font-size: 18pt;">DON'T MESS WITH STUFF THAT ISN'T YOURS</span></li><li><span style="font-size: 18pt;">DON'T ACCESS THE DOM DIRECTLY IF YOU CAN HELP IT</span></li><li><span style="font-size: 18pt;">BE EXPLICIT WITH SHARED VARIABLES BY PUTTING THEM IN A UI SCRIPT</span></li><li><span style="font-size: 18pt;">glide.script.block.client.globals IS A WORKAROUND (SOMETIMES)</span></li></ul><p><span style="font-size: 18pt;"><br/></span></p><p><span style="font-size: 18pt;"><span style="font-size: 10pt;">I hope that was informative.</span><br/></span></p>